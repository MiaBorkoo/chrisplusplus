4-Person Team Workload Division and Integration Plan
Team Structure and Responsibilities
Person 1: TOFU & Out-of-Band Verification (Medium Complexity)
Core Focus: Identity management, certificate handling, trust establishment
Person 2: File Management & Sharing (High Complexity)
Core Focus: File encryption, DEK management, sharing mechanisms
Person 3: Passwords & Multi-Device Authentication (High Complexity)
Core Focus: Key derivation, session management, device registration
Person 4: TOTP Authentication (Low Complexity)
Core Focus: 2FA implementation, backup codes, recovery

1. Person 1: TOFU & Out-of-Band Verification
Primary Responsibilities
Core Components:

Identity certificate generation and verification
Trust store management (local certificate storage)
TOFU prompt system and user decision handling
Out-of-band verification methods (QR codes, voice verification)
Certificate change detection and warnings

Key Data Structures:
DeviceCertificate {
  user_id: string
  device_id: string  
  identity_public_key: Ed25519PublicKey
  created_at: timestamp
  expires_at: timestamp
  self_signature: Ed25519Signature
}

TrustStoreEntry {
  user_id: string
  device_certificates: DeviceCertificate[]
  trust_level: "tofu" | "oob_verified" | "untrusted"
  trusted_at: timestamp
  verification_history: VerificationEvent[]
}
Integration Points
Interfaces Person 1 Must Provide:
// Called by Person 3 during device registration
generate_device_certificate(user_id: string, device_id: string, identity_keypair: Ed25519KeyPair) -> DeviceCertificate

// Called by Person 2 before file sharing
check_recipient_trust(recipient_user_id: string) -> TrustCheckResult {
  is_trusted: boolean
  trust_level: string
  certificates: DeviceCertificate[]
  requires_tofu_prompt: boolean
}

// Called by Person 2 to handle TOFU decisions
handle_tofu_prompt(recipient_user_id: string, certificates: DeviceCertificate[]) -> TOFUDecision {
  decision: "trust" | "verify_oob" | "reject"
  verification_method?: "qr_code" | "voice_verification"
}

// Called by Person 2 after successful sharing
record_successful_interaction(recipient_user_id: string, interaction_type: string)

// Called by any component to get recipient public keys
get_trusted_public_keys(recipient_user_id: string) -> Ed25519PublicKey[]
Interfaces Person 1 Must Use:
// From Person 3 - Get server certificates
fetch_user_certificates(user_id: string) -> ServerResponse<DeviceCertificate[]>

// From Person 4 - Verify operations with 2FA when needed
require_2fa_for_trust_decision(operation: string) -> boolean
Implementation Timeline (Person 1):

Days 1-2: Certificate generation and basic trust store
Days 3-4: TOFU prompt system and decision handling
Days 5-6: Out-of-band verification (QR codes)
Day 7: Integration testing and certificate change detection


2. Person 2: File Management & Sharing
Primary Responsibilities
Core Components:

File encryption/decryption with AES-256-GCM
DEK (Data Encryption Key) generation and management
Envelope encryption for DEK sharing
File upload/download with integrity verification
Share record creation and management
File metadata handling and signing

Key Data Structures:
EncryptedFile {
  file_id: UUID
  encrypted_data: bytes
  metadata: EncryptedFileMetadata
  content_signature: Ed25519Signature
}

FileMetadata {
  filename: string (encrypted)
  file_size: number (encrypted)  
  mime_type: string (encrypted)
  upload_timestamp: number
  owner_id: string
}

ShareRecord {
  share_id: UUID
  file_id: UUID
  sender_id: string
  recipient_id: string
  encrypted_deks: Map<device_id, EncryptedDEK>
  share_signature: Ed25519Signature
  created_at: timestamp
}
Integration Points
Interfaces Person 2 Must Provide:
// Called by UI/main application
encrypt_and_upload_file(file_data: bytes, filename: string, mime_type: string) -> FileUploadResult {
  file_id: UUID
  success: boolean
  error?: string
}

// Called by UI/main application  
download_and_decrypt_file(file_id: UUID) -> FileDownloadResult {
  file_data: bytes
  filename: string
  mime_type: string
  success: boolean
  sender_verified: boolean
}

// Called by UI/main application
share_file_with_user(file_id: UUID, recipient_user_id: string) -> ShareResult {
  share_id: UUID
  success: boolean
  trust_verification_required: boolean
}

// Called by UI/main application
list_accessible_files() -> FileListResult {
  owned_files: FileInfo[]
  shared_files: SharedFileInfo[]
}
Interfaces Person 2 Must Use:
// From Person 1 - Trust and certificate management
check_recipient_trust(recipient_user_id: string) -> TrustCheckResult
handle_tofu_prompt(recipient_user_id: string, certificates: DeviceCertificate[]) -> TOFUDecision  
get_trusted_public_keys(recipient_user_id: string) -> Ed25519PublicKey[]
record_successful_interaction(recipient_user_id: string, interaction_type: string)

// From Person 3 - Authentication and key management
get_current_mek() -> MasterEncryptionKey
get_user_identity_keypair() -> Ed25519KeyPair
get_current_session() -> SessionInfo

// From Person 4 - 2FA verification for sensitive operations
verify_2fa_for_sharing(operation_details: string) -> boolean
Implementation Timeline (Person 2):

Days 1-2: File encryption/decryption and DEK management
Days 3-4: File upload/download and basic sharing
Days 5-6: Integration with TOFU system and envelope encryption
Day 7: Share management and integrity verification


3. Person 3: Passwords & Multi-Device Authentication
Primary Responsibilities
Core Components:

Dual-key derivation (server auth key + MEK wrapper key)
MEK generation, encryption, and secure storage
Device registration and session management
Password change mechanism without data loss
Multi-device authentication coordination
Secure key storage and memory management

Key Data Structures:
UserCredentials {
  username: string
  auth_salt: bytes
  enc_salt: bytes
  server_key_hash: bytes
  encrypted_mek: bytes
}

SessionInfo {
  session_token: string
  user_id: string
  device_id: string
  expires_at: timestamp
  mek: MasterEncryptionKey
  identity_keypair: Ed25519KeyPair
}

DeviceRegistration {
  device_id: string
  user_id: string
  registered_at: timestamp
  last_login: timestamp
  device_certificate: DeviceCertificate
}
Integration Points
Interfaces Person 3 Must Provide:
// Called by UI/main application
register_new_user(username: string, password: string) -> RegistrationResult {
  user_id: string
  requires_2fa_setup: boolean
  success: boolean
}

// Called by UI/main application
login_user(username: string, password: string) -> LoginResult {
  temp_session?: string
  requires_2fa: boolean
  full_session?: SessionInfo
  success: boolean
}

// Called by UI/main application  
register_new_device(username: string, password: string) -> DeviceRegistrationResult {
  device_registered: boolean
  requires_2fa: boolean
  session_info?: SessionInfo
}

// Called by UI/main application
change_password(old_password: string, new_password: string) -> PasswordChangeResult {
  success: boolean
  new_session: SessionInfo
  requires_2fa: boolean
}

// Called by Person 2 for file operations
get_current_mek() -> MasterEncryptionKey
get_user_identity_keypair() -> Ed25519KeyPair  
get_current_session() -> SessionInfo

// Called by Person 1 for certificate operations
fetch_user_certificates(user_id: string) -> ServerResponse<DeviceCertificate[]>
Interfaces Person 3 Must Use:
// From Person 1 - Certificate generation
generate_device_certificate(user_id: string, device_id: string, identity_keypair: Ed25519KeyPair) -> DeviceCertificate

// From Person 4 - 2FA integration
generate_2fa_secret() -> TOTPSecret
verify_2fa_code(secret: TOTPSecret, code: string) -> boolean
setup_2fa_for_user(user_id: string) -> TOTPSetupResult
Implementation Timeline (Person 3):

Days 1-2: Key derivation and MEK management
Days 3-4: User registration and basic login
Days 5-6: Multi-device support and password changes
Day 7: Session management and security hardening


4. Person 4: TOTP Authentication
Primary Responsibilities
Core Components:

TOTP secret generation and QR code creation
TOTP code verification and validation
Backup code generation and management
2FA setup and recovery flows
Integration with authentication flows

Key Data Structures:
TOTPSecret {
  user_id: string
  secret: string
  qr_code_url: string
  backup_codes: string[]
  created_at: timestamp
}

TOTPVerification {
  user_id: string
  code: string
  timestamp: number
  is_valid: boolean
  attempts_remaining: number
}
Integration Points
Interfaces Person 4 Must Provide:
// Called by Person 3 during registration
generate_2fa_secret() -> TOTPSecret {
  secret: string
  qr_code_url: string
  backup_codes: string[]
}

// Called by Person 3 during login
verify_2fa_code(user_id: string, code: string) -> VerificationResult {
  is_valid: boolean
  attempts_remaining: number
  account_locked: boolean
}

// Called by Person 3 for user setup
setup_2fa_for_user(user_id: string) -> TOTPSetupResult {
  totp_secret: TOTPSecret
  setup_complete: boolean
}

// Called by any component requiring 2FA verification
require_2fa_for_operation(user_id: string, operation: string) -> boolean
verify_2fa_for_operation(user_id: string, code: string, operation: string) -> boolean

// Called by UI for recovery scenarios
verify_backup_code(user_id: string, backup_code: string) -> BackupCodeResult {
  is_valid: boolean
  remaining_codes: number
}

// Called by UI for 2FA management
regenerate_backup_codes(user_id: string) -> string[]
disable_2fa(user_id: string, verification_code: string) -> boolean
Interfaces Person 4 Must Use:
// From Person 3 - Session and user management
get_user_session(user_id: string) -> SessionInfo
is_user_authenticated(session_token: string) -> boolean
Implementation Timeline (Person 4):

Days 1-2: TOTP generation and basic verification
Days 3-4: Integration with login/registration flows
Days 5-6: Backup codes and recovery mechanisms
Day 7: Security hardening and rate limiting


Integration Coordination
Shared Dependencies
Common Data Types (All Teams Need):
typescript// Cryptographic primitives
Ed25519KeyPair { private_key: bytes, public_key: bytes }
Ed25519PublicKey { key: bytes }
Ed25519Signature { signature: bytes }
MasterEncryptionKey { key: bytes }

// Network responses
ServerResponse<T> { data?: T, success: boolean, error?: string }

// Common identifiers
UUID: string
timestamp: number (Unix timestamp)
Shared Configuration:
// Cryptographic parameters
ARGON2_MEMORY_KB = 64 * 1024
ARGON2_ITERATIONS = 3  
ARGON2_PARALLELISM = 2
AES_KEY_SIZE = 256
ED25519_KEY_SIZE = 256

// Session management
SESSION_EXPIRE_HOURS = 24
TEMP_SESSION_EXPIRE_MINUTES = 5
MAX_LOGIN_ATTEMPTS = 5
Integration Testing Strategy
Day-by-Day Integration Milestones:
Day 3: Person 3 & 4 Integration

Basic login with 2FA working
User registration with TOTP setup

Day 5: Person 1 & 3 Integration

Device certificate generation during registration
Certificate fetching during login

Day 6: Person 2 Integration with All

File encryption using MEK from Person 3
File sharing using TOFU from Person 1
2FA verification for sharing from Person 4

Day 7: Full System Integration

End-to-end file sharing between devices
Password changes preserving file access
TOFU prompts during first-time sharing

Critical Handoff Points

Person 3 → Person 1: Identity keypair generation must happen before certificate creation
Person 1 → Person 2: Trust verification must complete before DEK encryption
Person 4 → Person 3: 2FA verification must integrate into session creation
Person 2 → All: File operations need session info, trust data, and 2FA verification

Communication Protocols
Daily Standup Focus:

Day 1-2: API interface definitions and data structure alignment
Day 3-4: Integration point testing and debugging
Day 5-6: End-to-end workflow validation
Day 7: Security review and performance optimization

This division balances workload complexity while maintaining clear separation of concerns and well-defined integration points.